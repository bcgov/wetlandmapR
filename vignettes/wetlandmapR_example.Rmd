---
title: "wetlandmapR Example"
output: rmarkdown::html_vignette
author: "Deepa Filatow, Gillian Harvey, Hunter Gleason"
vignette: > 
  %\VignetteIndexEntry{wetlandmapR Example}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---
  
  
  Using example data provided with the package the following vignette demonstrates the use of the [wetlandmapR](https://github.com/bcgov/wetlandmapR) package to classify wetlands using terrain derivatives and external inputs such as satellite imagery. This document is written to serve as a reference for performing similar classification in any area of interest. 
  
## Using the wetlandmapr Docker ...
  
  A Docker image based on the [**rocker/geospatial:3.6.3**](https://hub.docker.com/r/rocker/geospatial) image has been assembled for running the [wetlandmapR package](https://github.com/bcgov/wetlandmapR) package. Please see the [Docker Install](https://docs.docker.com/engine/install/) page for platform specific guidance on installing Docker. Assuming a local installation of Docker is in place, the [huntgdok/wetlandmapr:latest](https://hub.docker.com/repository/docker/huntgdok/geospat) Docker image can be downloaded by passing the command below from your terminal or command prompt: 
  
  ```{bash eval=FALSE}
  docker pull huntgdok/wetlandmapr:latest
  ```
  once the image has been successfully pulled, it can be run from the terminal or command prompt using the docker run call as shown below  
  
  ```{bash eval=FALSE}
  docker run -e PASSWORD=APassword -e ROOT=TRUE -p 8787:8787 -v "/c/User/Desktop/Data:/home/rstudio/Data" --rm huntgdok/wetlandmapr:latest
  ```
  
  where *APassword* is any password you want to use to log into *rocker*. To use with sudo privileges, add *-e ROOT=TRUE* to the docker run call as shown above.  The *-v* flag in the Docker run call above mounts a volume on the host machine, in this case */c/User/Desktop/Data* on a Windows machine, to a directory called *Data* on the Docker container, see [Use Volumes](https://docs.docker.com/storage/volumes/) for more information about mounting volumes. To view the running docker, go to the local URL [localhost](http://localhost:8787) *http://localhost:8787* in your internet browser. When prompted for a *username* and *password*, supply *rstudio* as a username, and the password that you set with the *docker run* call. You should then have a R-Studio session running with all the R and third party dependencies required for running the [**wetlandmapR**](https://github.com/bcgov/wetlandmapR) package. 
  
  Alternatively, the package can be run locally assuming all of the required dependencies are installed.
  
## Load R package dependencies ... 
  
```{r message=FALSE, warning=FALSE}
library(wetlandmapR)
library(sf)
library(tidyverse)
library(bcmaps)
library(RStoolbox)
library(doParallel)
library(rgrass7)
library(tools)
library(terra)
```


## Creating elevation derivatives ... 

The following lines of code define an output directory for the terrain derivatives, load in an example digital elevation model (DEM) from the [wetlandmapR package](https://github.com/bcgov/wetlandmapR), and calls the ***wetlandmapR::create_dem_products*** function to generate terrain derivatives using [SAGA-GIS](http://www.saga-gis.org/) and [RSAGA](https://CRAN.R-project.org/package=RSAGA). These terrain derivatives will be used to predict the wetland classes.  As a pre-processing step, ***wetlandmapR::create_dem_products*** first hydrologically conditions the DEM by filling any sinks, a binary sinks layer is output under the name *SINKS.sgrd*. Optionally, if a stream vector is provided (*stream_vec*) it may be burned into the DEM by a distance (*burn_val*) in meters defined by the user. The terrain derivative layers specified by *products* (default all) are output to the directory provided to *outdir*. 

```{r message=FALSE, warning=FALSE, results = FALSE}

#Specify a output directory, we'll use the temporary directory for this example
out_dir<-paste(tempdir(),"/wetlandmapR_expl",sep="")
dir.create(out_dir)

#Load a example digital elevation model DEM from wetlandmapR package 
target_dem <- rast(system.file('extdata','DEM.tif',package = 'wetlandmapR'))

target_dem<-project(target_dem,st_crs(3005)$wkt)

writeRaster(target_dem,file.path(tempdir(),'dem.tif'))

target_dem<-file.path(tempdir(),'dem.tif')

#Load freshwater atlas stream data from wetlandmapR package
streams <- system.file('extdata','streams.shp',package = 'wetlandmapR')

#Create SAGA elevation derivatives using the wetlandmapR 'create_dem_products' function, burn FWA streams into DEM by 2 m ...
create_dem_products(dem=target_dem,stream_vec = streams, burn_val=2, outdir=out_dir,param_vect = c("TPI"),param_values = list(list(DW_WEIGHTING=2)))
```

## Creating the raster stack, adding external predictors ... 

In the code chunk below we create a list of paths to the raster images that we want to use to predict the different wetland classes, in this case most of the inputs were derived from the DEM using ***wetlandmapR::create_dem_products*** in the code above. However, in the example we add to this list a Sentinel-2 MSI Level-2A Band-4 (B4:Red) image as an additional predictor of the wetland classes. Note, any raster layer that the user wants to include for predicting the wetland classes can be added to the input list. We then call the ***wetlandmapR::stack_rasters*** function to create a *raster stack* object from the list of raster inputs specified by the *rasters* parameter. The *outdir* parameter is an optional output path defining where the stacked rasters are to be saved in '.img' format. When the aligned parameter is FALSE (default), the input raster will be re-sampled to the resolution and extent of a target raster provided by the *target_raster* parameter, in this case the provided DEM. The *rastLUTfn* is an optional parameter specifying the filename of a output raster lookup table (rastLUT) .csv file for use in ***wetlandmapR::wetland_map***. The resulting raster stack object is plotted below. 

```{r fig.width=6, fig.height=6, message=FALSE, warning=FALSE, results = FALSE, fig.cap="Raster stack of SAGA terrain derivatives and Sentinel-2 Band 4 image."}

#Get list of SAGA terrain derivatives within the output directory 
raster_list <- list.files(out_dir, "sdat$", full.names = TRUE)

#Drop the DEM w/ sinks and ASPECT layers from predictor list
raster_list<-raster_list[!raster_list %in% c(file.path(out_dir,'ELEV_NoSink.sdat'),file.path(out_dir,'ASPECT.sdat'))]

#E.g., Add external Sentinel-2 Band 4 data to the list of raster inputs from wetlandmapR package 
raster_list<-append(raster_list,system.file("extdata", "B4_SENT2.tif", package = "wetlandmapR"))

#Stack all raster inputs using the wetlandmapR 'stack_raster' function, passing 'raster_list' as input, output a raster Look-Up-Table 'rastLUT' CSV 
raster_stack <- stack_rasters(rasters = raster_list,
                              target_raster = target_dem,
                              outdir = out_dir,
                              rastLUTfn = out_dir, 
                              rastNames = file_path_sans_ext(basename(raster_list)))

#Plot the new stack of raster objects (input layers)
plot(raster_stack)

```

## Attribute raster values to training points ...

This code chunck reads in example training points from the [wetlandmapR](https://github.com/bcgov/wetlandmapR) package as a *sp* object with the wetland classes coded by the *T_W_Class_* field. In addition, biogeoclimatic zones (BEC) are loaded internally using the [bcmaps](https://github.com/bcgov/bcmaps) package, model outputs will be grouped by this layer by setting it as the *aoi* parameter. Using the raster stack of predictors plotted above as the *x* parameter, the ***wetlandmapR::grid_values_at_sp*** function attributes the intersecting raster values to the training points provided as the *y* parameter. Optionally, the resulting table table can be written to the output directory (*filename*) as a CSV, in this case named *"train_pnts_attributed.csv"*.


```{r fig.width=6, fig.height=6, message=FALSE, warning=FALSE, results=FALSE, fig.cap="Sample points and BEC-ZONE AOI polygons."}
#Load training data as sp  
training_points<-vect(system.file('extdata', 'TrainingPnts.shp', package = 'wetlandmapR'))

#Clip training point to subset AOI 
ext<-ext(raster_stack)
xmin = ext$xmin
xmax = ext$xmax
ymin=ext$ymin
ymax=ext$ymax
ext <- st_sfc(st_polygon(x = list(rbind(c(xmin, ymin), c(xmax, ymin), c(xmax, ymax), c(xmin, ymax), c(xmin, ymin)))), crs = st_crs(training_points))
training_points <- st_intersection(st_as_sf(training_points),ext)


#Load BEC zones from bcmaps 
aoi_polys<-bec(ask=F) %>% st_crop(training_points)

#Plot AOIs and training points
ggplot()+geom_sf(data=aoi_polys,aes(fill=ZONE))+
  geom_sf(data=training_points)

#Convert training_points and aoi_polys to SpatVect
aoi_polys<-vect(aoi_polys)
training_points<-vect(training_points)

training_points<-project(training_points,crs(raster_stack))

#Assign filepath for output CSV
attributed_csv <- file.path(out_dir,"train_pnts_attributed.csv")



#Attribute training points with intersected input raster values grouped by provided BEC AOI, write results to CSV. 
attributed_pnts<-grid_values_at_sp(raster_stack=raster_stack,
                  points=training_points,
                  filename = attributed_csv,
                  aoi = aoi_polys)


```

##  Setup predictor list and raster look-up-table (LUT) ...

Read in the *rastLUT.csv* file which was output by ***wetlandmapR::stack_rasters***, the first column of this CSV contains the file path to each input raster layer, while the second column indicates the name of the layer, and the third column indicates the band index to use, we recommend providing only single band inputs. Here we get a list of the raster layer names from the *rastLUT* table, and create a new directory for our model outputs within our current output directory.

```{r message=FALSE, warning=FALSE}
#Read in rastLUT table as data.frame from the rastLUTfn path provide to 'stack_rasters' above
rastLUT <- read.csv(file.path(out_dir,'rastLUT.csv'),
                    header = FALSE,
                    stringsAsFactors = FALSE)

#View rastLUT table 
rastLUT

#Get the list of input predictor names (2nd column)
predList <- rastLUT[,2]


#Create a model output directory called 'output' within 'out_dir' directory
dir.create(file.path(out_dir,"output"))

```





